// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BOOK_GRAPH_H_
#define FLATBUFFERS_GENERATED_BOOK_GRAPH_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace Graph {

struct Level;

struct Book;
struct BookBuilder;

struct LevelUpdate;

struct BookUpdate;
struct BookUpdateBuilder;

struct FullBookUpdate;
struct FullBookUpdateBuilder;

enum BookUpdateType : int16_t {
  BookUpdateType_Update = 0,
  BookUpdateType_Snapshot = 1,
  BookUpdateType_MIN = BookUpdateType_Update,
  BookUpdateType_MAX = BookUpdateType_Snapshot
};

inline const BookUpdateType (&EnumValuesBookUpdateType())[2] {
  static const BookUpdateType values[] = {
    BookUpdateType_Update,
    BookUpdateType_Snapshot
  };
  return values;
}

inline const char * const *EnumNamesBookUpdateType() {
  static const char * const names[3] = {
    "Update",
    "Snapshot",
    nullptr
  };
  return names;
}

inline const char *EnumNameBookUpdateType(BookUpdateType e) {
  if (::flatbuffers::IsOutRange(e, BookUpdateType_Update, BookUpdateType_Snapshot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBookUpdateType()[index];
}

enum LevelUpdateType : int16_t {
  LevelUpdateType_New = 0,
  LevelUpdateType_Change = 1,
  LevelUpdateType_Delete = 2,
  LevelUpdateType_Republish = 3,
  LevelUpdateType_MIN = LevelUpdateType_New,
  LevelUpdateType_MAX = LevelUpdateType_Republish
};

inline const LevelUpdateType (&EnumValuesLevelUpdateType())[4] {
  static const LevelUpdateType values[] = {
    LevelUpdateType_New,
    LevelUpdateType_Change,
    LevelUpdateType_Delete,
    LevelUpdateType_Republish
  };
  return values;
}

inline const char * const *EnumNamesLevelUpdateType() {
  static const char * const names[5] = {
    "New",
    "Change",
    "Delete",
    "Republish",
    nullptr
  };
  return names;
}

inline const char *EnumNameLevelUpdateType(LevelUpdateType e) {
  if (::flatbuffers::IsOutRange(e, LevelUpdateType_New, LevelUpdateType_Republish)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLevelUpdateType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Level FLATBUFFERS_FINAL_CLASS {
 private:
  Graph::Price price_;
  Graph::Size size_;
  Graph::Size recent_size_;
  Graph::Timestamp last_update_;

 public:
  Level()
      : price_(),
        size_(),
        recent_size_(),
        last_update_() {
  }
  Level(const Graph::Price &_price, const Graph::Size &_size, const Graph::Size &_recent_size, const Graph::Timestamp &_last_update)
      : price_(_price),
        size_(_size),
        recent_size_(_recent_size),
        last_update_(_last_update) {
  }
  const Graph::Price &price() const {
    return price_;
  }
  const Graph::Size &size() const {
    return size_;
  }
  const Graph::Size &recent_size() const {
    return recent_size_;
  }
  const Graph::Timestamp &last_update() const {
    return last_update_;
  }
};
FLATBUFFERS_STRUCT_END(Level, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) LevelUpdate FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t type_;
  int16_t padding0__;  int32_t padding1__;
  Graph::Level level_;

 public:
  LevelUpdate()
      : type_(0),
        padding0__(0),
        padding1__(0),
        level_() {
    (void)padding0__;
    (void)padding1__;
  }
  LevelUpdate(Graph::LevelUpdateType _type, const Graph::Level &_level)
      : type_(::flatbuffers::EndianScalar(static_cast<int16_t>(_type))),
        padding0__(0),
        padding1__(0),
        level_(_level) {
    (void)padding0__;
    (void)padding1__;
  }
  Graph::LevelUpdateType type() const {
    return static_cast<Graph::LevelUpdateType>(::flatbuffers::EndianScalar(type_));
  }
  const Graph::Level &level() const {
    return level_;
  }
};
FLATBUFFERS_STRUCT_END(LevelUpdate, 40);

struct Book FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BookBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDS = 4,
    VT_ASKS = 6
  };
  const ::flatbuffers::Vector<const Graph::Level *> *bids() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_BIDS);
  }
  const ::flatbuffers::Vector<const Graph::Level *> *asks() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_ASKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.EndTable();
  }
};

struct BookBuilder {
  typedef Book Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bids(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids) {
    fbb_.AddOffset(Book::VT_BIDS, bids);
  }
  void add_asks(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks) {
    fbb_.AddOffset(Book::VT_ASKS, asks);
  }
  explicit BookBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Book> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Book>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Book> CreateBook(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks = 0) {
  BookBuilder builder_(_fbb);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Book> CreateBookDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<Graph::Level> *bids = nullptr,
    const std::vector<Graph::Level> *asks = nullptr) {
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<Graph::Level>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<Graph::Level>(*asks) : 0;
  return Graph::CreateBook(
      _fbb,
      bids__,
      asks__);
}

struct BookUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BookUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TIMESTAMP_EXCHANGE = 6,
    VT_ID = 8,
    VT_BIDS = 10,
    VT_ASKS = 12,
    VT_TYPE = 14
  };
  const Graph::Timestamp *timestamp() const {
    return GetStruct<const Graph::Timestamp *>(VT_TIMESTAMP);
  }
  const Graph::Timestamp *timestamp_exchange() const {
    return GetStruct<const Graph::Timestamp *>(VT_TIMESTAMP_EXCHANGE);
  }
  const Graph::InstrumentId *id() const {
    return GetPointer<const Graph::InstrumentId *>(VT_ID);
  }
  const ::flatbuffers::Vector<const Graph::Level *> *bids() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_BIDS);
  }
  const ::flatbuffers::Vector<const Graph::Level *> *asks() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_ASKS);
  }
  Graph::BookUpdateType type() const {
    return static_cast<Graph::BookUpdateType>(GetField<int16_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Graph::Timestamp>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<Graph::Timestamp>(verifier, VT_TIMESTAMP_EXCHANGE, 8) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           VerifyField<int16_t>(verifier, VT_TYPE, 2) &&
           verifier.EndTable();
  }
};

struct BookUpdateBuilder {
  typedef BookUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(const Graph::Timestamp *timestamp) {
    fbb_.AddStruct(BookUpdate::VT_TIMESTAMP, timestamp);
  }
  void add_timestamp_exchange(const Graph::Timestamp *timestamp_exchange) {
    fbb_.AddStruct(BookUpdate::VT_TIMESTAMP_EXCHANGE, timestamp_exchange);
  }
  void add_id(::flatbuffers::Offset<Graph::InstrumentId> id) {
    fbb_.AddOffset(BookUpdate::VT_ID, id);
  }
  void add_bids(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids) {
    fbb_.AddOffset(BookUpdate::VT_BIDS, bids);
  }
  void add_asks(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks) {
    fbb_.AddOffset(BookUpdate::VT_ASKS, asks);
  }
  void add_type(Graph::BookUpdateType type) {
    fbb_.AddElement<int16_t>(BookUpdate::VT_TYPE, static_cast<int16_t>(type), 0);
  }
  explicit BookUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BookUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BookUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BookUpdate> CreateBookUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Graph::Timestamp *timestamp = nullptr,
    const Graph::Timestamp *timestamp_exchange = nullptr,
    ::flatbuffers::Offset<Graph::InstrumentId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks = 0,
    Graph::BookUpdateType type = Graph::BookUpdateType_Update) {
  BookUpdateBuilder builder_(_fbb);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_id(id);
  builder_.add_timestamp_exchange(timestamp_exchange);
  builder_.add_timestamp(timestamp);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BookUpdate> CreateBookUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Graph::Timestamp *timestamp = nullptr,
    const Graph::Timestamp *timestamp_exchange = nullptr,
    ::flatbuffers::Offset<Graph::InstrumentId> id = 0,
    const std::vector<Graph::Level> *bids = nullptr,
    const std::vector<Graph::Level> *asks = nullptr,
    Graph::BookUpdateType type = Graph::BookUpdateType_Update) {
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<Graph::Level>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<Graph::Level>(*asks) : 0;
  return Graph::CreateBookUpdate(
      _fbb,
      timestamp,
      timestamp_exchange,
      id,
      bids__,
      asks__,
      type);
}

struct FullBookUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FullBookUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_TIMESTAMP_EXCHANGE = 6,
    VT_ID = 8,
    VT_BIDS = 10,
    VT_ASKS = 12
  };
  const Graph::Timestamp *timestamp() const {
    return GetStruct<const Graph::Timestamp *>(VT_TIMESTAMP);
  }
  const Graph::Timestamp *timestamp_exchange() const {
    return GetStruct<const Graph::Timestamp *>(VT_TIMESTAMP_EXCHANGE);
  }
  const Graph::InstrumentId *id() const {
    return GetPointer<const Graph::InstrumentId *>(VT_ID);
  }
  const ::flatbuffers::Vector<const Graph::Level *> *bids() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_BIDS);
  }
  const ::flatbuffers::Vector<const Graph::Level *> *asks() const {
    return GetPointer<const ::flatbuffers::Vector<const Graph::Level *> *>(VT_ASKS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Graph::Timestamp>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<Graph::Timestamp>(verifier, VT_TIMESTAMP_EXCHANGE, 8) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyTable(id()) &&
           VerifyOffset(verifier, VT_BIDS) &&
           verifier.VerifyVector(bids()) &&
           VerifyOffset(verifier, VT_ASKS) &&
           verifier.VerifyVector(asks()) &&
           verifier.EndTable();
  }
};

struct FullBookUpdateBuilder {
  typedef FullBookUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(const Graph::Timestamp *timestamp) {
    fbb_.AddStruct(FullBookUpdate::VT_TIMESTAMP, timestamp);
  }
  void add_timestamp_exchange(const Graph::Timestamp *timestamp_exchange) {
    fbb_.AddStruct(FullBookUpdate::VT_TIMESTAMP_EXCHANGE, timestamp_exchange);
  }
  void add_id(::flatbuffers::Offset<Graph::InstrumentId> id) {
    fbb_.AddOffset(FullBookUpdate::VT_ID, id);
  }
  void add_bids(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids) {
    fbb_.AddOffset(FullBookUpdate::VT_BIDS, bids);
  }
  void add_asks(::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks) {
    fbb_.AddOffset(FullBookUpdate::VT_ASKS, asks);
  }
  explicit FullBookUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FullBookUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FullBookUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FullBookUpdate> CreateFullBookUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Graph::Timestamp *timestamp = nullptr,
    const Graph::Timestamp *timestamp_exchange = nullptr,
    ::flatbuffers::Offset<Graph::InstrumentId> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> bids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const Graph::Level *>> asks = 0) {
  FullBookUpdateBuilder builder_(_fbb);
  builder_.add_asks(asks);
  builder_.add_bids(bids);
  builder_.add_id(id);
  builder_.add_timestamp_exchange(timestamp_exchange);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FullBookUpdate> CreateFullBookUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Graph::Timestamp *timestamp = nullptr,
    const Graph::Timestamp *timestamp_exchange = nullptr,
    ::flatbuffers::Offset<Graph::InstrumentId> id = 0,
    const std::vector<Graph::Level> *bids = nullptr,
    const std::vector<Graph::Level> *asks = nullptr) {
  auto bids__ = bids ? _fbb.CreateVectorOfStructs<Graph::Level>(*bids) : 0;
  auto asks__ = asks ? _fbb.CreateVectorOfStructs<Graph::Level>(*asks) : 0;
  return Graph::CreateFullBookUpdate(
      _fbb,
      timestamp,
      timestamp_exchange,
      id,
      bids__,
      asks__);
}

inline const Graph::BookUpdate *GetBookUpdate(const void *buf) {
  return ::flatbuffers::GetRoot<Graph::BookUpdate>(buf);
}

inline const Graph::BookUpdate *GetSizePrefixedBookUpdate(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Graph::BookUpdate>(buf);
}

inline bool VerifyBookUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Graph::BookUpdate>(nullptr);
}

inline bool VerifySizePrefixedBookUpdateBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Graph::BookUpdate>(nullptr);
}

inline void FinishBookUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Graph::BookUpdate> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBookUpdateBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Graph::BookUpdate> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Graph

#endif  // FLATBUFFERS_GENERATED_BOOK_GRAPH_H_
