// <auto-generated>
//     Generated SBE (Simple Binary Encoding) message codec
// </auto-generated>

#pragma warning disable 1591 // disable warning on missing comments
using System;
using System.Text;
using Org.SbeTool.Sbe.Dll;

namespace Extension
{
    /// <summary>
    /// Description of a basic Car
    /// </summary>
    public sealed partial class Car
    {
        public const ushort BlockLength = (ushort)62;
        public const ushort TemplateId = (ushort)1;
        public const ushort SchemaId = (ushort)1;
        public const ushort SchemaVersion = (ushort)1;
        public const string SemanticType = "";

        private readonly Car _parentMessage;
        private DirectBuffer _buffer;
        private int _offset;
        private int _limit;
        private int _actingBlockLength;
        private int _actingVersion;

        public int Offset { get { return _offset; } }

        public Car()
        {
            _parentMessage = this;
        }

        public void WrapForEncode(DirectBuffer buffer, int offset)
        {
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = BlockLength;
            _actingVersion = SchemaVersion;
            Limit = offset + _actingBlockLength;
        }

        public void WrapForEncodeAndApplyHeader(DirectBuffer buffer, int offset,  MessageHeader headerEncoder)
        {
            headerEncoder.Wrap(buffer, offset, SchemaVersion);
            headerEncoder.BlockLength = BlockLength;
            headerEncoder.TemplateId = TemplateId;
            headerEncoder.SchemaId = SchemaId;
            headerEncoder.Version = SchemaVersion;
            
            WrapForEncode(buffer, offset + MessageHeader.Size);
        }

        public void WrapForDecode(DirectBuffer buffer, int offset, int actingBlockLength, int actingVersion)
        {
            _buffer = buffer;
            _offset = offset;
            _actingBlockLength = actingBlockLength;
            _actingVersion = actingVersion;
            Limit = offset + _actingBlockLength;
        }

        public int Size
        {
            get
            {
                return _limit - _offset;
            }
        }

        public int Limit
        {
            get
            {
                return _limit;
            }
            set
            {
                _buffer.CheckLimit(value);
                _limit = value;
            }
        }


        public const int SerialNumberId = 1;
    public const int SerialNumberSinceVersion = 0;
    public const int SerialNumberDeprecated = 0;
    public bool SerialNumberInActingVersion()
    {
        return _actingVersion >= SerialNumberSinceVersion;
    }

        public const int SerialNumberOffset = 0;

        public static string SerialNumberMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ulong SerialNumberNullValue = 0xffffffffffffffffUL;
        public const ulong SerialNumberMinValue = 0x0UL;
        public const ulong SerialNumberMaxValue = 0xfffffffffffffffeUL;

        public ulong SerialNumber
        {
            get
            {
                return _buffer.Uint64GetLittleEndian(_offset + 0);
            }
            set
            {
                _buffer.Uint64PutLittleEndian(_offset + 0, value);
            }
        }


        public const int ModelYearId = 2;
    public const int ModelYearSinceVersion = 0;
    public const int ModelYearDeprecated = 0;
    public bool ModelYearInActingVersion()
    {
        return _actingVersion >= ModelYearSinceVersion;
    }

        public const int ModelYearOffset = 8;

        public static string ModelYearMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const ushort ModelYearNullValue = (ushort)65535;
        public const ushort ModelYearMinValue = (ushort)0;
        public const ushort ModelYearMaxValue = (ushort)65534;

        public ushort ModelYear
        {
            get
            {
                return _buffer.Uint16GetLittleEndian(_offset + 8);
            }
            set
            {
                _buffer.Uint16PutLittleEndian(_offset + 8, value);
            }
        }


        public const int AvailableId = 3;
    public const int AvailableSinceVersion = 0;
    public const int AvailableDeprecated = 0;
    public bool AvailableInActingVersion()
    {
        return _actingVersion >= AvailableSinceVersion;
    }

        public const int AvailableOffset = 10;

        public static string AvailableMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public BooleanType Available
        {
            get
            {
                return (BooleanType)_buffer.Uint8Get(_offset + 10);
            }
            set
            {
                _buffer.Uint8Put(_offset + 10, (byte)value);
            }
        }


        public const int CodeId = 4;
    public const int CodeSinceVersion = 0;
    public const int CodeDeprecated = 0;
    public bool CodeInActingVersion()
    {
        return _actingVersion >= CodeSinceVersion;
    }

        public const int CodeOffset = 11;

        public static string CodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public Model Code
        {
            get
            {
                return (Model)_buffer.CharGet(_offset + 11);
            }
            set
            {
                _buffer.CharPut(_offset + 11, (byte)value);
            }
        }


        public const int SomeNumbersId = 5;
    public const int SomeNumbersSinceVersion = 0;
    public const int SomeNumbersDeprecated = 0;
    public bool SomeNumbersInActingVersion()
    {
        return _actingVersion >= SomeNumbersSinceVersion;
    }

        public const int SomeNumbersOffset = 12;

        public static string SomeNumbersMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const uint SomeNumbersNullValue = 4294967295U;
        public const uint SomeNumbersMinValue = 0U;
        public const uint SomeNumbersMaxValue = 4294967294U;

        public const int SomeNumbersLength = 4;

        public uint GetSomeNumbers(int index)
        {
            if ((uint) index >= 4)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.Uint32GetLittleEndian(_offset + 12 + (index * 4));
        }

        public void SetSomeNumbers(int index, uint value)
        {
            if ((uint) index >= 4)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.Uint32PutLittleEndian(_offset + 12 + (index * 4), value);
        }

        public ReadOnlySpan<uint> SomeNumbers
        {
            get => _buffer.AsReadOnlySpan<uint>(_offset + 12, SomeNumbersLength);
            set => value.CopyTo(_buffer.AsSpan<uint>(_offset + 12, SomeNumbersLength));
        }

        public Span<uint> SomeNumbersAsSpan()
        {
            return _buffer.AsSpan<uint>(_offset + 12, SomeNumbersLength);
        }

        public const int VehicleCodeId = 6;
    public const int VehicleCodeSinceVersion = 0;
    public const int VehicleCodeDeprecated = 0;
    public bool VehicleCodeInActingVersion()
    {
        return _actingVersion >= VehicleCodeSinceVersion;
    }

        public const int VehicleCodeOffset = 28;

        public static string VehicleCodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const byte VehicleCodeNullValue = (byte)0;
        public const byte VehicleCodeMinValue = (byte)32;
        public const byte VehicleCodeMaxValue = (byte)126;

        public const int VehicleCodeLength = 6;

        public byte GetVehicleCode(int index)
        {
            if ((uint) index >= 6)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            return _buffer.CharGet(_offset + 28 + (index * 1));
        }

        public void SetVehicleCode(int index, byte value)
        {
            if ((uint) index >= 6)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.CharPut(_offset + 28 + (index * 1), value);
        }

        public ReadOnlySpan<byte> VehicleCode
        {
            get => _buffer.AsReadOnlySpan<byte>(_offset + 28, VehicleCodeLength);
            set => value.CopyTo(_buffer.AsSpan<byte>(_offset + 28, VehicleCodeLength));
        }

        public Span<byte> VehicleCodeAsSpan()
        {
            return _buffer.AsSpan<byte>(_offset + 28, VehicleCodeLength);
        }

        public const string VehicleCodeCharacterEncoding = "ASCII";
        public static Encoding VehicleCodeResolvedCharacterEncoding = Encoding.GetEncoding(VehicleCodeCharacterEncoding);


        public int GetVehicleCode(byte[] dst, int dstOffset)
        {
            const int length = 6;
            return GetVehicleCode(new Span<byte>(dst, dstOffset, length));
        }

        public int GetVehicleCode(Span<byte> dst)
        {
            const int length = 6;
            if (dst.Length < length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooSmall(dst.Length);
            }

            _buffer.GetBytes(_offset + 28, dst);
            return length;
        }

        public void SetVehicleCode(byte[] src, int srcOffset)
        {
            SetVehicleCode(new ReadOnlySpan<byte>(src, srcOffset, src.Length - srcOffset));
        }

        public void SetVehicleCode(ReadOnlySpan<byte> src)
        {
            const int length = 6;
            if (src.Length > length)
            {
                ThrowHelper.ThrowWhenSpanLengthTooLarge(src.Length);
            }

            _buffer.SetBytes(_offset + 28, src);
        }

        public void SetVehicleCode(string value)
        {
            _buffer.SetNullTerminatedBytesFromString(VehicleCodeResolvedCharacterEncoding, value, _offset + 28, VehicleCodeLength, VehicleCodeNullValue);
        }
        public string GetVehicleCode()
        {
            return _buffer.GetStringFromNullTerminatedBytes(VehicleCodeResolvedCharacterEncoding, _offset + 28, VehicleCodeLength, VehicleCodeNullValue);
        }

        public const int ExtrasId = 7;
    public const int ExtrasSinceVersion = 0;
    public const int ExtrasDeprecated = 0;
    public bool ExtrasInActingVersion()
    {
        return _actingVersion >= ExtrasSinceVersion;
    }

        public const int ExtrasOffset = 34;

        public static string ExtrasMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public OptionalExtras Extras
        {
            get
            {
                return (OptionalExtras)_buffer.Uint8Get(_offset + 34);
            }
            set
            {
                _buffer.Uint8Put(_offset + 34, (byte)value);
            }
        }

        public const int DiscountedModelId = 8;
    public const int DiscountedModelSinceVersion = 0;
    public const int DiscountedModelDeprecated = 0;
    public bool DiscountedModelInActingVersion()
    {
        return _actingVersion >= DiscountedModelSinceVersion;
    }

        public const int DiscountedModelOffset = 35;

        public static string DiscountedModelMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "constant";
            }

            return "";
        }

        public Model DiscountedModel
        {
            get
            {
                return Model.C;
            }
        }


        public const int EngineId = 9;
    public const int EngineSinceVersion = 0;
    public const int EngineDeprecated = 0;
    public bool EngineInActingVersion()
    {
        return _actingVersion >= EngineSinceVersion;
    }

        public const int EngineOffset = 35;

        public static string EngineMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        private readonly Engine _engine = new Engine();

        public Engine Engine
        {
            get
            {
                _engine.Wrap(_buffer, _offset + 35, _actingVersion);
                return _engine;
            }
        }

        public const int UuidId = 100;
    public const int UuidSinceVersion = 1;
    public const int UuidDeprecated = 0;
    public bool UuidInActingVersion()
    {
        return _actingVersion >= UuidSinceVersion;
    }

        public const int UuidOffset = 45;

        public static string UuidMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "optional";
            }

            return "";
        }

        public const long UuidNullValue = -9223372036854775808L;
        public const long UuidMinValue = -9223372036854775807L;
        public const long UuidMaxValue = 9223372036854775807L;

        public const int UuidLength = 2;

        public long GetUuid(int index)
        {
            if ((uint) index >= 2)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

                if (_actingVersion < 1) return -9223372036854775808L;

            return _buffer.Int64GetLittleEndian(_offset + 45 + (index * 8));
        }

        public void SetUuid(int index, long value)
        {
            if ((uint) index >= 2)
            {
                ThrowHelper.ThrowIndexOutOfRangeException(index);
            }

            _buffer.Int64PutLittleEndian(_offset + 45 + (index * 8), value);
        }

        public ReadOnlySpan<long> Uuid
        {
            get => _buffer.AsReadOnlySpan<long>(_offset + 45, UuidLength);
            set => value.CopyTo(_buffer.AsSpan<long>(_offset + 45, UuidLength));
        }

        public Span<long> UuidAsSpan()
        {
            return _buffer.AsSpan<long>(_offset + 45, UuidLength);
        }

        public const int CupHolderCountId = 101;
    public const int CupHolderCountSinceVersion = 1;
    public const int CupHolderCountDeprecated = 0;
    public bool CupHolderCountInActingVersion()
    {
        return _actingVersion >= CupHolderCountSinceVersion;
    }

        public const int CupHolderCountOffset = 61;

        public static string CupHolderCountMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "optional";
            }

            return "";
        }

        public const byte CupHolderCountNullValue = (byte)255;
        public const byte CupHolderCountMinValue = (byte)0;
        public const byte CupHolderCountMaxValue = (byte)254;

        public byte CupHolderCount
        {
            get
            {
                if (_actingVersion < 1) return (byte)255;

                return _buffer.Uint8Get(_offset + 61);
            }
            set
            {
                _buffer.Uint8Put(_offset + 61, value);
            }
        }


        private readonly FuelFiguresGroup _fuelFigures = new FuelFiguresGroup();

        public const long FuelFiguresId = 10;
        public const int FuelFiguresSinceVersion = 0;
        public const int FuelFiguresDeprecated = 0;
        public bool FuelFiguresInActingVersion()
        {
            return _actingVersion >= FuelFiguresSinceVersion;
        }

        public FuelFiguresGroup FuelFigures
        {
            get
            {
                _fuelFigures.WrapForDecode(_parentMessage, _buffer, _actingVersion);
                return _fuelFigures;
            }
        }

        public FuelFiguresGroup FuelFiguresCount(int count)
        {
            _fuelFigures.WrapForEncode(_parentMessage, _buffer, count);
            return _fuelFigures;
        }

        public sealed partial class FuelFiguresGroup
        {
            private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
            private Car _parentMessage;
            private DirectBuffer _buffer;
            private int _blockLength;
            private int _actingVersion;
            private int _count;
            private int _index;
            private int _offset;

            public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
            {
                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _blockLength = _dimensions.BlockLength;
                _count = (int) _dimensions.NumInGroup;
                _actingVersion = actingVersion;
                _index = 0;
            }

            public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
            {
                if ((uint) count > 65534)
                {
                    ThrowHelper.ThrowCountOutOfRangeException(count);
                }

                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _dimensions.BlockLength = SbeBlockLength;
                _dimensions.NumInGroup = (ushort) count;
                _index = 0;
                _count = count;
                _blockLength = SbeBlockLength;
                _actingVersion = SchemaVersion;
            }

            public const int SbeBlockLength = 6;
            public const int SbeHeaderSize = 4;
            public int ActingBlockLength { get { return _blockLength; } }

            public int Count { get { return _count; } }

            public bool HasNext { get { return _index < _count; } }

            public int ResetCountToIndex()
            {
                _count = _index;
                _dimensions.NumInGroup = (ushort) _count;

                return _count;
            }

            public FuelFiguresGroup Next()
            {
                if (_index >= _count)
                {
                    ThrowHelper.ThrowInvalidOperationException();
                }

                _offset = _parentMessage.Limit;
                _parentMessage.Limit = _offset + _blockLength;
                ++_index;

                return this;
            }

            public System.Collections.IEnumerator GetEnumerator()
            {
                while (this.HasNext)
                {
                    yield return this.Next();
                }
            }

            public const int SpeedId = 11;
        public const int SpeedSinceVersion = 0;
        public const int SpeedDeprecated = 0;
        public bool SpeedInActingVersion()
        {
            return _actingVersion >= SpeedSinceVersion;
        }

            public const int SpeedOffset = 0;

            public static string SpeedMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            public const ushort SpeedNullValue = (ushort)65535;
            public const ushort SpeedMinValue = (ushort)0;
            public const ushort SpeedMaxValue = (ushort)65534;

            public ushort Speed
            {
                get
                {
                    return _buffer.Uint16GetLittleEndian(_offset + 0);
                }
                set
                {
                    _buffer.Uint16PutLittleEndian(_offset + 0, value);
                }
            }


            public const int MpgId = 12;
        public const int MpgSinceVersion = 0;
        public const int MpgDeprecated = 0;
        public bool MpgInActingVersion()
        {
            return _actingVersion >= MpgSinceVersion;
        }

            public const int MpgOffset = 2;

            public static string MpgMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            public const float MpgNullValue = float.NaN;
            public const float MpgMinValue = 1.401298464324817E-45f;
            public const float MpgMaxValue = 3.4028234663852886E38f;

            public float Mpg
            {
                get
                {
                    return _buffer.FloatGetLittleEndian(_offset + 2);
                }
                set
                {
                    _buffer.FloatPutLittleEndian(_offset + 2, value);
                }
            }


            public const int UsageDescriptionId = 200;
            public const int UsageDescriptionSinceVersion = 0;
            public const int UsageDescriptionDeprecated = 0;
            public bool UsageDescriptionInActingVersion()
            {
                return _actingVersion >= UsageDescriptionSinceVersion;
            }

            public const int UsageDescriptionOffset = 6;

            public const string UsageDescriptionCharacterEncoding = "ASCII";
            public static Encoding UsageDescriptionResolvedCharacterEncoding = Encoding.GetEncoding(UsageDescriptionCharacterEncoding);


            public static string UsageDescriptionMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            public const int UsageDescriptionHeaderSize = 4;
            
            public int UsageDescriptionLength()
            {
                _buffer.CheckLimit(_parentMessage.Limit + 4);
                return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
            }

            public int GetUsageDescription(byte[] dst, int dstOffset, int length) =>
                GetUsageDescription(new Span<byte>(dst, dstOffset, length));

            public int GetUsageDescription(Span<byte> dst)
            {
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                int bytesCopied = Math.Min(dst.Length, dataLength);
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

                return bytesCopied;
            }
            
            // Allocates and returns a new byte array
            public byte[] GetUsageDescriptionBytes()
            {
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                byte[] data = new byte[dataLength];
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                _buffer.GetBytes(limit + sizeOfLengthField, data);

                return data;
            }

            public int SetUsageDescription(byte[] src, int srcOffset, int length) =>
                SetUsageDescription(new ReadOnlySpan<byte>(src, srcOffset, length));

            public int SetUsageDescription(ReadOnlySpan<byte> src)
            {
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
                _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
                _buffer.SetBytes(limit + sizeOfLengthField, src);

                return src.Length;
            }

            public string GetUsageDescription()
            {
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                _buffer.CheckLimit(limit + sizeOfLengthField);
                int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
                _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
                return _buffer.GetStringFromBytes(UsageDescriptionResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
            }

            public void SetUsageDescription(string value)
            {
                var encoding = UsageDescriptionResolvedCharacterEncoding;
                const int sizeOfLengthField = 4;
                int limit = _parentMessage.Limit;
                int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
                _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
                _buffer.Uint32PutLittleEndian(limit, (ushort)byteCount);
            }

                internal void BuildString(StringBuilder builder)
                {
                    if (_buffer == null)
                    {
                        return;
                    }

                    builder.Append('(');
                    builder.Append("Speed=");
                    builder.Append(this.Speed);
                    builder.Append('|');
                    builder.Append("Mpg=");
                    builder.Append(this.Mpg);
                    builder.Append('|');
                    builder.Append("UsageDescription=");
                    builder.Append('\'').Append(GetUsageDescription()).Append('\'');
                    builder.Append(')');

                }
        }

        private readonly PerformanceFiguresGroup _performanceFigures = new PerformanceFiguresGroup();

        public const long PerformanceFiguresId = 13;
        public const int PerformanceFiguresSinceVersion = 0;
        public const int PerformanceFiguresDeprecated = 0;
        public bool PerformanceFiguresInActingVersion()
        {
            return _actingVersion >= PerformanceFiguresSinceVersion;
        }

        public PerformanceFiguresGroup PerformanceFigures
        {
            get
            {
                _performanceFigures.WrapForDecode(_parentMessage, _buffer, _actingVersion);
                return _performanceFigures;
            }
        }

        public PerformanceFiguresGroup PerformanceFiguresCount(int count)
        {
            _performanceFigures.WrapForEncode(_parentMessage, _buffer, count);
            return _performanceFigures;
        }

        public sealed partial class PerformanceFiguresGroup
        {
            private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
            private Car _parentMessage;
            private DirectBuffer _buffer;
            private int _blockLength;
            private int _actingVersion;
            private int _count;
            private int _index;
            private int _offset;

            public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
            {
                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _blockLength = _dimensions.BlockLength;
                _count = (int) _dimensions.NumInGroup;
                _actingVersion = actingVersion;
                _index = 0;
            }

            public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
            {
                if ((uint) count > 65534)
                {
                    ThrowHelper.ThrowCountOutOfRangeException(count);
                }

                _parentMessage = parentMessage;
                _buffer = buffer;
                _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                _dimensions.BlockLength = SbeBlockLength;
                _dimensions.NumInGroup = (ushort) count;
                _index = 0;
                _count = count;
                _blockLength = SbeBlockLength;
                _actingVersion = SchemaVersion;
            }

            public const int SbeBlockLength = 1;
            public const int SbeHeaderSize = 4;
            public int ActingBlockLength { get { return _blockLength; } }

            public int Count { get { return _count; } }

            public bool HasNext { get { return _index < _count; } }

            public int ResetCountToIndex()
            {
                _count = _index;
                _dimensions.NumInGroup = (ushort) _count;

                return _count;
            }

            public PerformanceFiguresGroup Next()
            {
                if (_index >= _count)
                {
                    ThrowHelper.ThrowInvalidOperationException();
                }

                _offset = _parentMessage.Limit;
                _parentMessage.Limit = _offset + _blockLength;
                ++_index;

                return this;
            }

            public System.Collections.IEnumerator GetEnumerator()
            {
                while (this.HasNext)
                {
                    yield return this.Next();
                }
            }

            public const int OctaneRatingId = 14;
        public const int OctaneRatingSinceVersion = 0;
        public const int OctaneRatingDeprecated = 0;
        public bool OctaneRatingInActingVersion()
        {
            return _actingVersion >= OctaneRatingSinceVersion;
        }

            public const int OctaneRatingOffset = 0;

            public static string OctaneRatingMetaAttribute(MetaAttribute metaAttribute)
            {
                switch (metaAttribute)
                {
                    case MetaAttribute.Epoch: return "";
                    case MetaAttribute.TimeUnit: return "";
                    case MetaAttribute.SemanticType: return "";
                    case MetaAttribute.Presence: return "required";
                }

                return "";
            }

            public const byte OctaneRatingNullValue = (byte)255;
            public const byte OctaneRatingMinValue = (byte)90;
            public const byte OctaneRatingMaxValue = (byte)110;

            public byte OctaneRating
            {
                get
                {
                    return _buffer.Uint8Get(_offset + 0);
                }
                set
                {
                    _buffer.Uint8Put(_offset + 0, value);
                }
            }


            private readonly AccelerationGroup _acceleration = new AccelerationGroup();

            public const long AccelerationId = 15;
            public const int AccelerationSinceVersion = 0;
            public const int AccelerationDeprecated = 0;
            public bool AccelerationInActingVersion()
            {
                return _actingVersion >= AccelerationSinceVersion;
            }

            public AccelerationGroup Acceleration
            {
                get
                {
                    _acceleration.WrapForDecode(_parentMessage, _buffer, _actingVersion);
                    return _acceleration;
                }
            }

            public AccelerationGroup AccelerationCount(int count)
            {
                _acceleration.WrapForEncode(_parentMessage, _buffer, count);
                return _acceleration;
            }

            public sealed partial class AccelerationGroup
            {
                private readonly GroupSizeEncoding _dimensions = new GroupSizeEncoding();
                private Car _parentMessage;
                private DirectBuffer _buffer;
                private int _blockLength;
                private int _actingVersion;
                private int _count;
                private int _index;
                private int _offset;

                public void WrapForDecode(Car parentMessage, DirectBuffer buffer, int actingVersion)
                {
                    _parentMessage = parentMessage;
                    _buffer = buffer;
                    _dimensions.Wrap(buffer, parentMessage.Limit, actingVersion);
                    _parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                    _blockLength = _dimensions.BlockLength;
                    _count = (int) _dimensions.NumInGroup;
                    _actingVersion = actingVersion;
                    _index = 0;
                }

                public void WrapForEncode(Car parentMessage, DirectBuffer buffer, int count)
                {
                    if ((uint) count > 65534)
                    {
                        ThrowHelper.ThrowCountOutOfRangeException(count);
                    }

                    _parentMessage = parentMessage;
                    _buffer = buffer;
                    _dimensions.Wrap(buffer, parentMessage.Limit, SchemaVersion);
                    parentMessage.Limit = parentMessage.Limit + SbeHeaderSize;
                    _dimensions.BlockLength = SbeBlockLength;
                    _dimensions.NumInGroup = (ushort) count;
                    _index = 0;
                    _count = count;
                    _blockLength = SbeBlockLength;
                    _actingVersion = SchemaVersion;
                }

                public const int SbeBlockLength = 6;
                public const int SbeHeaderSize = 4;
                public int ActingBlockLength { get { return _blockLength; } }

                public int Count { get { return _count; } }

                public bool HasNext { get { return _index < _count; } }

                public int ResetCountToIndex()
                {
                    _count = _index;
                    _dimensions.NumInGroup = (ushort) _count;

                    return _count;
                }

                public AccelerationGroup Next()
                {
                    if (_index >= _count)
                    {
                        ThrowHelper.ThrowInvalidOperationException();
                    }

                    _offset = _parentMessage.Limit;
                    _parentMessage.Limit = _offset + _blockLength;
                    ++_index;

                    return this;
                }

                public System.Collections.IEnumerator GetEnumerator()
                {
                    while (this.HasNext)
                    {
                        yield return this.Next();
                    }
                }

                public const int MphId = 16;
            public const int MphSinceVersion = 0;
            public const int MphDeprecated = 0;
            public bool MphInActingVersion()
            {
                return _actingVersion >= MphSinceVersion;
            }

                public const int MphOffset = 0;

                public static string MphMetaAttribute(MetaAttribute metaAttribute)
                {
                    switch (metaAttribute)
                    {
                        case MetaAttribute.Epoch: return "";
                        case MetaAttribute.TimeUnit: return "";
                        case MetaAttribute.SemanticType: return "";
                        case MetaAttribute.Presence: return "required";
                    }

                    return "";
                }

                public const ushort MphNullValue = (ushort)65535;
                public const ushort MphMinValue = (ushort)0;
                public const ushort MphMaxValue = (ushort)65534;

                public ushort Mph
                {
                    get
                    {
                        return _buffer.Uint16GetLittleEndian(_offset + 0);
                    }
                    set
                    {
                        _buffer.Uint16PutLittleEndian(_offset + 0, value);
                    }
                }


                public const int SecondsId = 17;
            public const int SecondsSinceVersion = 0;
            public const int SecondsDeprecated = 0;
            public bool SecondsInActingVersion()
            {
                return _actingVersion >= SecondsSinceVersion;
            }

                public const int SecondsOffset = 2;

                public static string SecondsMetaAttribute(MetaAttribute metaAttribute)
                {
                    switch (metaAttribute)
                    {
                        case MetaAttribute.Epoch: return "";
                        case MetaAttribute.TimeUnit: return "";
                        case MetaAttribute.SemanticType: return "";
                        case MetaAttribute.Presence: return "required";
                    }

                    return "";
                }

                public const float SecondsNullValue = float.NaN;
                public const float SecondsMinValue = 1.401298464324817E-45f;
                public const float SecondsMaxValue = 3.4028234663852886E38f;

                public float Seconds
                {
                    get
                    {
                        return _buffer.FloatGetLittleEndian(_offset + 2);
                    }
                    set
                    {
                        _buffer.FloatPutLittleEndian(_offset + 2, value);
                    }
                }


                    internal void BuildString(StringBuilder builder)
                    {
                        if (_buffer == null)
                        {
                            return;
                        }

                        builder.Append('(');
                        builder.Append("Mph=");
                        builder.Append(this.Mph);
                        builder.Append('|');
                        builder.Append("Seconds=");
                        builder.Append(this.Seconds);
                        builder.Append(')');

                    }
            }

                internal void BuildString(StringBuilder builder)
                {
                    if (_buffer == null)
                    {
                        return;
                    }

                    builder.Append('(');
                    builder.Append("OctaneRating=");
                    builder.Append(this.OctaneRating);
                    builder.Append('|');
                    builder.Append("Acceleration=[");
                    var acceleration = this.Acceleration;
                    if (acceleration.Count > 0)
                    {
                        var first = true;
                        while (acceleration.HasNext)
                        {
                            if (!first)
                            {
                                builder.Append(',');
                            }
                            first = false;
                            acceleration.Next().BuildString(builder);
                        }
                    }
                    builder.Append("]");
                    builder.Append(')');

                }
        }

        public const int ManufacturerId = 18;
        public const int ManufacturerSinceVersion = 0;
        public const int ManufacturerDeprecated = 0;
        public bool ManufacturerInActingVersion()
        {
            return _actingVersion >= ManufacturerSinceVersion;
        }

        public const int ManufacturerOffset = -1;

        public const string ManufacturerCharacterEncoding = "UTF-8";
        public static Encoding ManufacturerResolvedCharacterEncoding = Encoding.GetEncoding(ManufacturerCharacterEncoding);


        public static string ManufacturerMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const int ManufacturerHeaderSize = 4;
        
        public int ManufacturerLength()
        {
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetManufacturer(byte[] dst, int dstOffset, int length) =>
            GetManufacturer(new Span<byte>(dst, dstOffset, length));

        public int GetManufacturer(Span<byte> dst)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetManufacturerBytes()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetManufacturer(byte[] src, int srcOffset, int length) =>
            SetManufacturer(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetManufacturer(ReadOnlySpan<byte> src)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetManufacturer()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ManufacturerResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetManufacturer(string value)
        {
            var encoding = ManufacturerResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (ushort)byteCount);
        }

        public const int ModelId = 19;
        public const int ModelSinceVersion = 0;
        public const int ModelDeprecated = 0;
        public bool ModelInActingVersion()
        {
            return _actingVersion >= ModelSinceVersion;
        }

        public const int ModelOffset = -1;

        public const string ModelCharacterEncoding = "UTF-8";
        public static Encoding ModelResolvedCharacterEncoding = Encoding.GetEncoding(ModelCharacterEncoding);


        public static string ModelMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const int ModelHeaderSize = 4;
        
        public int ModelLength()
        {
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetModel(byte[] dst, int dstOffset, int length) =>
            GetModel(new Span<byte>(dst, dstOffset, length));

        public int GetModel(Span<byte> dst)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetModelBytes()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetModel(byte[] src, int srcOffset, int length) =>
            SetModel(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetModel(ReadOnlySpan<byte> src)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetModel()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ModelResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetModel(string value)
        {
            var encoding = ModelResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (ushort)byteCount);
        }

        public const int ActivationCodeId = 20;
        public const int ActivationCodeSinceVersion = 0;
        public const int ActivationCodeDeprecated = 0;
        public bool ActivationCodeInActingVersion()
        {
            return _actingVersion >= ActivationCodeSinceVersion;
        }

        public const int ActivationCodeOffset = -1;

        public const string ActivationCodeCharacterEncoding = "ASCII";
        public static Encoding ActivationCodeResolvedCharacterEncoding = Encoding.GetEncoding(ActivationCodeCharacterEncoding);


        public static string ActivationCodeMetaAttribute(MetaAttribute metaAttribute)
        {
            switch (metaAttribute)
            {
                case MetaAttribute.Epoch: return "";
                case MetaAttribute.TimeUnit: return "";
                case MetaAttribute.SemanticType: return "";
                case MetaAttribute.Presence: return "required";
            }

            return "";
        }

        public const int ActivationCodeHeaderSize = 4;
        
        public int ActivationCodeLength()
        {
            _buffer.CheckLimit(_parentMessage.Limit + 4);
            return (int)_buffer.Uint32GetLittleEndian(_parentMessage.Limit);
        }

        public int GetActivationCode(byte[] dst, int dstOffset, int length) =>
            GetActivationCode(new Span<byte>(dst, dstOffset, length));

        public int GetActivationCode(Span<byte> dst)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            int bytesCopied = Math.Min(dst.Length, dataLength);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, dst.Slice(0, bytesCopied));

            return bytesCopied;
        }
        
        // Allocates and returns a new byte array
        public byte[] GetActivationCodeBytes()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            byte[] data = new byte[dataLength];
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            _buffer.GetBytes(limit + sizeOfLengthField, data);

            return data;
        }

        public int SetActivationCode(byte[] src, int srcOffset, int length) =>
            SetActivationCode(new ReadOnlySpan<byte>(src, srcOffset, length));

        public int SetActivationCode(ReadOnlySpan<byte> src)
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _parentMessage.Limit = limit + sizeOfLengthField + src.Length;
            _buffer.Uint32PutLittleEndian(limit, (uint)src.Length);
            _buffer.SetBytes(limit + sizeOfLengthField, src);

            return src.Length;
        }

        public string GetActivationCode()
        {
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            _buffer.CheckLimit(limit + sizeOfLengthField);
            int dataLength = (int)_buffer.Uint32GetLittleEndian(limit);
            _parentMessage.Limit = limit + sizeOfLengthField + dataLength;
            return _buffer.GetStringFromBytes(ActivationCodeResolvedCharacterEncoding, limit + sizeOfLengthField, dataLength);
        }

        public void SetActivationCode(string value)
        {
            var encoding = ActivationCodeResolvedCharacterEncoding;
            const int sizeOfLengthField = 4;
            int limit = _parentMessage.Limit;
            int byteCount = _buffer.SetBytesFromString(encoding, value, limit + sizeOfLengthField);
            _parentMessage.Limit = limit + sizeOfLengthField + byteCount;
            _buffer.Uint32PutLittleEndian(limit, (ushort)byteCount);
        }

        public override string ToString()
        {
            var sb = new StringBuilder(100);
            this.BuildString(sb);
            return sb.ToString();
        }

        internal void BuildString(StringBuilder builder)
        {
            if (_buffer == null)
            {
                throw new ArgumentNullException("_buffer");
            }

            int originalLimit = this.Limit;
            this.Limit = _offset + _actingBlockLength;
            builder.Append("[Car](sbeTemplateId=");
            builder.Append(Car.TemplateId);
            builder.Append("|sbeSchemaId=");
            builder.Append(Car.SchemaId);
            builder.Append("|sbeSchemaVersion=");
            if (_parentMessage._actingVersion != Car.SchemaVersion)
            {
                builder.Append(_parentMessage._actingVersion);
                builder.Append('/');
            }
            builder.Append(Car.SchemaVersion);
            builder.Append("|sbeBlockLength=");
            if (_actingBlockLength != Car.BlockLength)
            {
                builder.Append(_actingBlockLength);
                builder.Append('/');
            }
            builder.Append(Car.BlockLength);
            builder.Append("):");

            builder.Append("SerialNumber=");
            builder.Append(this.SerialNumber);
            builder.Append('|');
            builder.Append("ModelYear=");
            builder.Append(this.ModelYear);
            builder.Append('|');
            builder.Append("Available=");
            builder.Append(this.Available);
            builder.Append('|');
            builder.Append("Code=");
            builder.Append(this.Code);
            builder.Append('|');
            builder.Append("SomeNumbers=");
            builder.Append('[');
            for (int i = 0; i < SomeNumbersLength; ++i)
            {
                if (i > 0)
                {
                    builder.Append(',');
                }
                builder.Append(GetSomeNumbers(i));
            }
            builder.Append(']');
            builder.Append('|');
            builder.Append("VehicleCode=");
            for (int i = 0; i < VehicleCodeLength && this.GetVehicleCode(i) > 0; ++i)
            {
                builder.Append((char)this.GetVehicleCode(i));
            }
            builder.Append('|');
            builder.Append("Extras=");
            this.Extras.BuildString(builder);
            builder.Append('|');
            builder.Append("DiscountedModel=");
            builder.Append(this.DiscountedModel);
            builder.Append('|');
            builder.Append("Engine=");
            if (this.Engine != null)
            {
                this.Engine.BuildString(builder);
            }
            else
            {
                builder.Append("null");
            }
            builder.Append('|');
            builder.Append("Uuid=");
            builder.Append('[');
            for (int i = 0; i < UuidLength; ++i)
            {
                if (i > 0)
                {
                    builder.Append(',');
                }
                builder.Append(GetUuid(i));
            }
            builder.Append(']');
            builder.Append('|');
            builder.Append("CupHolderCount=");
            builder.Append(this.CupHolderCount);
            builder.Append('|');
            builder.Append("FuelFigures=[");
            var fuelFigures = this.FuelFigures;
            if (fuelFigures.Count > 0)
            {
                var first = true;
                while (fuelFigures.HasNext)
                {
                    if (!first)
                    {
                        builder.Append(',');
                    }
                    first = false;
                    fuelFigures.Next().BuildString(builder);
                }
            }
            builder.Append("]");
            builder.Append('|');
            builder.Append("PerformanceFigures=[");
            var performanceFigures = this.PerformanceFigures;
            if (performanceFigures.Count > 0)
            {
                var first = true;
                while (performanceFigures.HasNext)
                {
                    if (!first)
                    {
                        builder.Append(',');
                    }
                    first = false;
                    performanceFigures.Next().BuildString(builder);
                }
            }
            builder.Append("]");
            builder.Append('|');
            builder.Append("Manufacturer=");
            builder.Append('\'').Append(GetManufacturer()).Append('\'');
            builder.Append('|');
            builder.Append("Model=");
            builder.Append('\'').Append(GetModel()).Append('\'');
            builder.Append('|');
            builder.Append("ActivationCode=");
            builder.Append('\'').Append(GetActivationCode()).Append('\'');

            this.Limit = originalLimit;

        }
    }
}
